### CONFIG
hull:
  config:
    general:
      data:
        installation:
          config:
            customCaCertificates: {}
          endpoints:
            10_vidicore:
              auth:
                basic:
                  env:
                    username: VIDICORE_ADMIN_USERNAME
                    password: VIDICORE_ADMIN_PASSWORD
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: vidicore
                  ENDPOINT: api
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
            20_authservice:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
                  - 'configportalscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: authservice
                  ENDPOINT: api
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  identifierQueryParam: "resourceName"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  identifierQueryParam: "clientId"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  identifierQueryParam: "id"
                  _DEFAULTS_:
                    register: true
                    remove: false

            30_configportal:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
                  - 'identityscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: configportal
                  ENDPOINT: api
              subresources:
                10_product:
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                20_usecasedefinitions:
                  apiPath: "v2/UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                25_migrate:
                  apiPath: "v2/UseCaseDefinitions/Migrate"
                  typeDescription: UseCaseDefinitionsMigrate
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                30_usecaseconfiguration:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                40_metadata:
                  apiPath: "v2/Metadata"
                  typeDescription: "Metadata"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                50_roles:
                  apiPath: "v2/RoleRightsMapping/Mapping"
                  typeDescription: RoleRightsMapping
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true

###################################################

  objects:
    registry:
      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:
      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run Scipt;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              env:
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientId
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientSecret
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientId
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientSecret
                'VIDICORE_ADMIN_USERNAME':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminUsername
                'VIDICORE_ADMIN_PASSWORD':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminPassword
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              configMap:
                name: hull-install
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}

      'hull-configure':
        enabled: false
        annotations:
          "helm.sh/hook": post-install,post-upgrade
          "helm.sh/hook-delete-policy": before-hook-creation
          "helm.sh/hook-weight": '50'
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          volumes:
            installation:
              configMap:
                name: hull-install
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run Scipt;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              env:
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientId
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientSecret
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientId
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientSecret
                'VIDICORE_ADMIN_USERNAME':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminUsername
                'VIDICORE_ADMIN_PASSWORD':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminPassword
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              configMap:
                name: hull-install
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}

    secret:
      'vidicore-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          adminUsername:
            inline: ""
          adminPassword:
            inline: ""
          username:
            inline: ""
          password:
            inline: ""

      'authservice-token-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installerClientId:
            inline: ""
          installerClientSecret:
            inline: ""
          productClientId:
            inline: ""
          productClientSecret:
            inline: ""

      'custom-ca-certificates':
        enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: |-
          _HT!{
            {{ range $key,$value :=  (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
            {{ $key }}: { inline: {{ $value | quote }} },
            {{ end }}
          }

    configmap:
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
              {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := .endpoints -}}
                  {{- range $endpoint, $endpointval := .endpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $endpointval) -}}
                      {{- if $endpointval.endpoint -}}
                          {{- range $subresource, $subresourceval := $endpointval.subresources }}
                              {{- $subresourceScope := $subresourceval }}
                              {{- range $entity, $entityval := $subresourceval.entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
              {{ toYaml $configScope | indent 4 }}
              {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .PARAMETER Stage
                  Stage of execution in overal installation, valid options are 'pre-install' and 'post-install'. Defaults to 'pre-install'.
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml" -Stage "post-install"
              #>
              Param(
                  [string]$ConfigFilePath,
                  [string]$Stage = 'pre-install'
              )
              Import-Module powershell-yaml

              function ParseErrorForResponseBody($Error)
              {
                  try
                  {
                      if ($PSVersionTable.PSVersion.Major -lt 6)
                      {
                          if ($Error.Exception.Response)
                          {
                              $Reader = New-Object System.IO.StreamReader($Error.Exception.Response.GetResponseStream())
                              $Reader.BaseStream.Position = 0
                              $Reader.DiscardBufferedData()
                              $ResponseBody = $Reader.ReadToEnd()
                              if ($ResponseBody.StartsWith('{')) {
                                  $ResponseBody = $ResponseBody | ConvertFrom-Json
                              }
                              return $ResponseBody
                          }
                          return "<error getting body: Error.Exception.Response does not exist>"
                      }
                      else
                      {
                          return $Error.ErrorDetails.Message
                      }
                  }
                  catch
                  {
                    return "<error getting body: $($_.Exception.Message)"
                  }
              }

              [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath, $Stage)
              $installer.Start()
              Write-Host "----------- Installer finished processing all endpoints ----------"

              Class Installer
              {
                  hidden [PSCustomObject] $_config
                  hidden [string] $_stage

                  hidden [void] WriteLog($message) {
                      "$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)" | Write-Host
                  }

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine($message)
                      [Console]::ResetColor()
                  }

                  hidden [void] LogInvokeWebRequestError($uri, $method)
                  {
                      $this.WriteError("***** ERROR $($method.ToUpper()) to service: StatusCode: $($_.Exception.Response.StatusCode.Value__)")
                      $this.WriteError("***** ERROR -> Url: '$($uri)'. $($_.Exception.ToString())")
                      $this.WriteError("***** ERROR -> Exception Message: $($_.Exception.Message)")
                      if ($_.Exception.InnerException -ne $null)
                      {
                          $this.WriteError("****** ERROR -> Inner Exception Message: $($_.Exception.InnerException.Message)")
                      }
                      $this.WriteError("***** ERROR -> Body: $(ParseErrorForResponseBody($_))")
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = 5
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              $this.WriteLog("***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'")

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch {

                              $this.LogInvokeWebRequestError($url, $method)

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) time(s): $($_.Exception.Message)")
                                  throw $_.Exception.Message
                              }
                          }
                      } while ($retryCount -le $retryLimit)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetJsonHttpHeaders([PSCustomObject] $auth)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/json")
                      $headers.Add("Accept", "application/json")

                      $authHeader = ""
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                      }

                      $headers.Add("Authorization", $authHeader)
                      $this.WriteLog("++++ Authorization header: $authHeader")
                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      $this.WriteLog("++++ Getting access token.")

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"); "client_secret" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"); "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          $this.WriteLog("++++ Getting access token with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:")
                          foreach ($key in $headers.Keys)
                          {
                              $this.WriteLog("++++   Key: $key Value: $($headers[$key])")
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          $this.WriteLog("++++ Got access token: $token")
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = 30;

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      $this.WriteLog("++++ Pinging authentication service at '$($healthCheckUri)'")

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              $this.WriteLog("++++ Attempting to contact authenticatiun service. Retry count: " + $retryCount + " of " + $retryLimit)
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  $this.WriteLog("++++ Successfully connected to authentication service")
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              $this.WriteLog("**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})")
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath, $Stage)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                      $this._stage = $Stage
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          $this.WriteLog("** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)")
                          $scriptblock = [Scriptblock]::Create($script)
                          $this.WriteLog("[- Start Script -]")
                          & $scriptblock
                          $this.WriteLog("[- End Script -]")
                      }
                      else
                      {
                          $this.WriteLog("** No scripts to invoke found for step '$step'")
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      $this.WriteLog("---------- Starting all installations ----------")
                      $this.ExecuteScript("pre-install", $this._config.config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set.")
                              $this.WriteLog("")
                          }
                          else
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Starting installation for Endpoint '$($apiKey)'")
                              $this.WriteLog("")
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          $this.WriteLog("** Starting installation for Subresource '$($subresourceKey)'")

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth)

                          $this.WriteLog("** Finished installation for Subresource '$($subresourceKey)'")
                          $this.WriteLog("")
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $name, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth)
                  {
                    $processSubresource = $true
                    $stageSubresource = if ($subresource.Contains("stage")) { $subresource.stage } else { "pre-install" }
                    $this.WriteLog("*** Subresource stage is '$($stageSubresource)', global stage is '$($this._stage)'")
                    if ($stageSubresource.Equals($this._stage))
                    {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $name = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }

                              $this.WriteLog("*** $(if ($value.remove -eq $true) {"Starting to remove"} else {"Starting to register"}) Entity $($name) for entity key '$($entityKey)'")

                              $this.ReadConfigValueFromFile($value)

                              $this.CheckEntity(
                                  "$($endpoint)/$($subresource.apiPath)",
                                  $name,
                                  "$(if ($value.remove -eq $true) {[string]::empty} else { $value.config | ConvertTo-Json -Depth 20})",
                                  $subresource.typeDescription,
                                  $value.remove -eq $true,
                                  "$(if ($value.remove -eq $true) {$subresource.identifierQueryParam} else {''})",
                                  $auth,
                                  $value.putInsteadOfPost -eq $true,
                                  $value.putUriExcludeIdentifier -eq $true,
                                  $value.overwriteExisting -eq $true,
                                  $value.postQueryParams)
                          }
                          else
                          {
                              $this.WriteLog("*** Skipping subresource because neither 'register' nor 'remove' is set to true.")
                          }
                      }
                    }
                    else
                    {
                      $this.WriteLog("*** Subresource stage '$($stageSubresource)' does not match global stage '$($this._stage)', skip processing.")
                    }
                  }

                  # Read config value from file content
                  [void] ReadConfigValueFromFile([PSCustomObject] $value)
                  {
                      if ($value.configValueFromFile -ne $null)
                      {
                          foreach($entityKey in $value.configValueFromFile.Keys)
                          {
                              $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                              $filePath = Join-Path $currentPath $entityKey

                              if (!(Test-Path $filePath))
                              {
                                  $this.WriteLog("File '$($filePath)' does not exist")
                              }
                              else
                              {
                                  $fileContent = Get-Content -Path $filePath | Out-String
                                  $fileContentJson = $fileContent | ConvertFrom-Json

                                  $this.WriteLog("Config file found: " + $fileContentJson)

                                  $configs = $value.configValueFromFile[$entityKey]

                                  foreach($configEntityKey in $configs.Keys) {

                                      $configEntityValue = $configs[$configEntityKey]
                                      $configValue = $fileContentJson.$($configEntityValue.key)
                                      $value.config[$configEntityKey] = $configValue
                                  }
                              }
                          }
                      }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [void] CheckEntity([string] $apiEndpoint, [PSCustomObject] $identifier, [string] $bodyParams, [string] $entityType, [bool] $toBeDeleted, [string] $identifierQueryParam, [PSCustomObject] $auth, [bool] $putInsteadOfPost, [bool] $putUriExcludeIdentifier, [bool] $overwriteExisting, [PSCustomObject] $postQueryParams)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $apiEndpoint = $apiEndpoint.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($putUriExcludeIdentifier) { $apiEndpoint } else { $uri }

                      try
                      {
                          $this.WriteLog("**** Checking if entity exists, GETting uri '$($uri)''")
                          $response = Invoke-WebRequest -Uri $uri -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                          $statusCode = $response.StatusCode
                          $this.WriteLog("**** SUCCESS --> StatusCode: $($statusCode)")
                      }
                      catch
                      {
                          $statusCode = $_.Exception.Response.StatusCode.Value__
                          $this.LogInvokeWebRequestError($uri, "GET")
                      }

                      if ($statusCode -eq 200)
                      {
                          if($toBeDeleted) {
                              $this.WriteLog("**** '$entityType' entry '$identifier' already exists and ia going to be deleted now")
                              $this.DeleteEntity($apiEndpoint, $identifier, $identifierQueryParam, $auth)
                          }
                          else
                          {
                              if ($overwriteExisting)
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing to update entity")
                                  $this.PutEntity($uriPut, $bodyParams, $auth)
                              }
                              else
                              {
                                $this.WriteLog("**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set")
                              }
                          }

                      }
                      elseif ($statusCode -eq 404)
                      {
                          if($toBeDeleted) {
                              $this.WriteLog("**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done")
                          }
                          else
                          {
                              $this.WriteLog("**** '$entityType' entry '$identifier' does not exist and will be created now")
                              if ($putInsteadOfPost)
                              {
                                  $this.WriteLog("**** PUTting '$entityType' entry '$identifier' to create it since 'putInsteadOfPost' is set to true")
                                  $this.PutEntity($uriPut, $bodyParams, $auth)
                              }
                              else
                              {
                                  $this.WriteLog("**** POSTing '$entityType' entry '$identifier' to create it")
                                  $this.PostEntity($apiEndpoint, $bodyParams, $auth, $postQueryParams)
                              }

                          }
                      }
                      else
                      {
                          throw [Exception]::new("ERROR --> Unexpected StatusCode: $($_.Exception.Response.StatusCode.Value__). Exception was: $($_.Exception.Response)")
                      }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $json, [PSCustomObject] $auth, [PSCustomObject] $postQueryParams)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($postUrl)"

                      if ($postQueryParams -ne $null)
                      {
                          $count = 0
                          $start = "?"
                          foreach($key in $postQueryParams.Keys)
                          {
                              if ($count -gt 0)
                              {
                                  $start = "&"
                              }
                              $url += "$($start)$($key)=$($postQueryParams[$key])"
                              $count = $count + 1
                          }
                      }

                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $json, [PSCustomObject] $auth)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($putUrl)"

                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $identifierQueryParam, [PSCustomObject] $auth)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($deleteUrl.TrimEnd('/'))$(if ([string]::IsNullOrWhitespace($identifierQueryParam)) { [string]::Empty } else { "?$identifierQueryParam=$identifier" })"

                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }
              }