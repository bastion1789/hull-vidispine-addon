### CONFIG
hull:
  config:
    general:
      data:
        installation:
          config:
            productUris: null
          endpoints:
            10_vidispine:
              auth:
                basic:
                  env:
                    username: VIDISPINE_ADMIN_USERNAME
                    password: VIDISPINE_ADMIN_PASSWORD
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: vidispine
                  ENDPOINT: api
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
            20_authenticationService:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authenticationService
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: authenticationService
                  ENDPOINT: api
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  identifierQueryParam: "resourceName"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  identifierQueryParam: "clientId"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  identifierQueryParam: "id"
                  _DEFAULTS_:
                    register: true
                    remove: false

            30_configPortal:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authenticationService
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
                  - 'identityscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: configPortal
                  ENDPOINT: api
              subresources:
                10_product:
                  apiPath: "Products"
                  typeDescription: "Product"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                20_usecasedefinitions:
                  apiPath: "UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true

###################################################

  objects:
    registry:
      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:
      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          volumes:
            installation:
              configMap:
                name: hull-install
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command:
              - "pwsh"
              - "-c"
              - "/script/Installer.ps1"
              - "-ConfigFilePath"
              - "/script/installation.yaml"
              env:
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientId
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientSecret
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientId
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientSecret
                'VIDISPINE_ADMIN_USERNAME':
                  valueFrom:
                    secretKeyRef:
                      name: vidispine-secret
                      key: adminUsername
                'VIDISPINE_ADMIN_PASSWORD':
                  valueFrom:
                    secretKeyRef:
                      name: vidispine-secret
                      key: adminPassword
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script

    secret:
      'vidispine-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          adminUsername:
            inline: ""
          adminPassword:
            inline: ""
          username:
            inline: ""
          password:
            inline: ""

      'authservice-token-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installerClientId:
            inline: ""
          installerClientSecret:
            inline: ""
          productClientId:
            inline: ""
          productClientSecret:
            inline: ""

    configmap:
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
              {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := .endpoints -}}
                  {{- range $endpoint, $endpointval := .endpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $endpointval) -}}
                      {{- if $endpointval.endpoint -}}
                          {{- range $subresource, $subresourceval := $endpointval.subresources }}
                              {{- $subresourceScope := $subresourceval }}
                              {{- range $entity, $entityval := $subresourceval.entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
              {{ toYaml $configScope | indent 4 }}
              {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
              #>
              Param(
                  [string]$ConfigFilePath
              )
              Import-Module powershell-yaml

              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath)
              $installer.Start()
              Write-Host "----------- Installer finished processing all endpoints ----------"

              Class Installer
              {
                  hidden [PSCustomObject] $_config

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine($message)
                      [Console]::ResetColor()
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = 5
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              Write-Host "***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'"

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch [Microsoft.PowerShell.Commands.HttpResponseException] {
                              $this.WriteError("***** Failed $($method.ToUpper()) '$($url)': $($_.Exception.Message)")
                              $response = $_.Exception.Response;
                              return $response;
                          }
                          catch {
                              Write-Host "***** Error $($method.ToUpper()) to service. Url '$($url)'. $($_.Exception.ToString())"

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) time(s): $($_.Exception.Message)")
                                  throw $_.Exception.Message
                              }
                          }
                      } while ($retryCount -le $retryLimit)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetJsonHttpHeaders([PSCustomObject] $auth)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/json")
                      $headers.Add("Accept", "application/json")

                      $authHeader = ""
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                      }

                      $headers.Add("Authorization", $authHeader)
                      Write-Host "++++ Authorization header: $authHeader"
                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      Write-Host "++++ Getting access token."

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $headers.Add("Authorization", "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process") + ":" + [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"))))")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = "installerClient"; "client_secret" = "575810cd-cc43-4deb-8a6c-478e71d51427"; "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          Write-Host "++++ Getting access token with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:"
                          foreach ($key in $headers.Keys)
                          {
                              Write-Host "++++   Key: $key Value: $($headers[$key])"
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          Write-Host "++++ Got access token: $token"
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          Write-Host "** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)"
                          $scriptblock = [Scriptblock]::Create($script)
                          Write-Host "[- Start Script -]"
                          & $scriptblock
                          Write-Host "[- End Script -]"
                      }
                      else
                      {
                          Write-Host "** No scripts to invoke found for step '$step'"
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      Write-Host "---------- Starting all installations ----------"
                      $this.ExecuteScript("pre-install", $this._config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              Write-Host "* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set."
                          }
                          else
                          {
                              Write-Host "* Starting installation for Endpoint '$($apiKey)'"
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          Write-Host "** Starting installation for Subresource '$($subresourceKey)'"

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth)
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $name, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth)
                  {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $name = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }

                              Write-Host "*** $(if ($value.remove -eq $true) {"Removing"} else {"Registering"}) Entity $($name)"

                              $this.ReadConfigValueFromFile($value)

                              $this.CheckEntity(
                                  "$($endpoint)/$($subresource.apiPath)",
                                  $name,
                                  "$(if ($value.remove -eq $true) {[string]::empty} else { $value.config | ConvertTo-Json -Depth 20})",
                                  $subresource.typeDescription,
                                  $value.remove -eq $true,
                                  "$(if ($value.remove -eq $true) {$subresource.identifierQueryParam} else {''})",
                                  $auth,
                                  $value.putInsteadOfPost -eq $true,
                                  $value.putUriExcludeIdentifier -eq $true,
                                  $value.overwriteExisting -eq $true)
                          }
                          else
                          {
                              Write-Host "*** Neither 'register' nor 'remove' is enabled for Subresource $($name) and element $($entityKey), not processing entity."
                          }
                      }
                  }

                  # Read config value from file content
                  [void] ReadConfigValueFromFile([PSCustomObject] $value)
                  {
                      if ($value.configValueFromFile -ne $null)
                      {
                          foreach($entityKey in $value.configValueFromFile.Keys)
                          {
                              $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                              $filePath = Join-Path $currentPath $entityKey

                              if (!(Test-Path $filePath))
                              {
                                  Write-Host "File not exist"
                              }
                              else
                              {
                                  $fileContent = Get-Content -Path $filePath | Out-String
                                  $fileContentJson = $fileContent | ConvertFrom-Json

                                  Write-Host "Config file found : " $fileContentJson

                                  $configs = $value.configValueFromFile[$entityKey]

                                  foreach($configEntityKey in $configs.Keys) {

                                      $configEntityValue = $configs[$configEntityKey]
                                      $configValue = $fileContentJson.$($configEntityValue.key)
                                      $value.config[$configEntityKey] = $configValue
                                  }


                              }
                          }
                      }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [void] CheckEntity([string] $apiEndpoint, [PSCustomObject] $identifier, [string] $bodyParams, [string] $entityType, [bool] $toBeDeleted, [string] $identifierQueryParam, [PSCustomObject] $auth, [bool] $putInsteadOfPost, [bool] $putUriExcludeIdentifier, [bool] $overwriteExisting)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $apiEndpoint = $apiEndpoint.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($putUriExcludeIdentifier) { $apiEndpoint } else { $uri }

                      try
                      {
                          Write-Host "**** GETting uri '$($uri)''"
                          $response = Invoke-WebRequest -Uri $uri -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                          $statusCode = $response.StatusCode
                      }
                      catch
                      {
                          $statusCode = $_.Exception.Response.StatusCode.Value__
                          Write-Host "**** StatusCode: $($_.Exception.Response.StatusCode.Value__) Exception: $($_.Exception.Message)"
                      }

                      if ($statusCode -eq 200)
                      {
                          if($toBeDeleted) {
                              Write-Host "**** '$entityType' entry '$identifier' already exists and it will be deleted"
                              $this.DeleteEntity($apiEndpoint, $identifier, $identifierQueryParam, $auth)
                          }
                          else
                          {
                              if ($overwriteExisting)
                              {
                                  Write-Host "**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing"
                                  $this.PutEntity($uriPut, $bodyParams, $auth)
                              }
                              else
                              {
                                Write-Host "**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set."
                              }
                          }

                      }
                      elseif ($statusCode -eq 404)
                      {
                          if($toBeDeleted) {
                              Write-Host "**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done."
                          }
                          else
                          {
                              Write-Host "**** '$entityType' entry '$identifier' does not exist and will be created now."
                              if ($putInsteadOfPost)
                              {
                                  $this.PutEntity($uriPut, $bodyParams, $auth)
                              }
                              else
                              {
                                  $this.PostEntity($apiEndpoint, $bodyParams, $auth)
                              }

                          }
                      }
                      else
                      {
                        throw [Exception]::new("Unexpected StatusCode: $($_.Exception.Response.StatusCode.Value__). Exception was: $($_.Exception.Response)")
                      }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $json, [PSCustomObject] $auth)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($postUrl)"

                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $json, [PSCustomObject] $auth)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($putUrl)"

                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $identifierQueryParam, [PSCustomObject] $auth)
                  {
                      $headers = $this.GetJsonHttpHeaders($auth)
                      $url = "$($deleteUrl.TrimEnd('/'))$(if ([string]::IsNullOrWhitespace($identifierQueryParam)) { [string]::Empty } else { "?$identifierQueryParam=$identifier" })"

                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = 30;

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      Write-Host "**** Pinging authentication service at '$($healthCheckUri)'"

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              Write-Host "**** Attempting to contact configuration service. Retry count: " + $retryCount + " of " + $retryLimit
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  Write-Host "**** Successfully connected to authentication service"
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              Write-Host "**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})"
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }
              }
